using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using Mud.DataStructures.Trie;
using Mud.Domain;
using Mud.Logger;
using Mud.Server.Abilities;
using Mud.Server.Blueprints.Character;
using Mud.Server.Common;
using Mud.Server.Entity;
using Mud.Server.Helpers;
using Mud.Server.Input;
using Mud.Server.Item;
using Mud.Server.Server;

namespace Mud.Server.Character
{
    public partial class Character : EntityBase, ICharacter
    {
        private static readonly Lazy<IReadOnlyTrie<CommandMethodInfo>> CharacterCommands = new Lazy<IReadOnlyTrie<CommandMethodInfo>>(() => CommandHelpers.GetCommands(typeof(Character)));

        private readonly Trie<CommandMethodInfo> _fullCommands; // CharacterCommands + autogenerated commands from skills
        private readonly List<IItem> _inventory;
        private readonly List<EquipedItem> _equipments;
        private readonly List<IPeriodicAura> _periodicAuras;
        private readonly List<IAura> _auras;
        // TODO: replace int[] with Dictionary<enum,int> ?
        private readonly int[] _basePrimaryAttributes; // modified when levelling
        private readonly int[] _currentPrimaryAttributes; // = base attribute + buff
        private readonly int[] _secondaryAttributes; // secondary attributes (in recompute)
        private readonly int[] _maxResources;
        private readonly int[] _currentResources;
        private readonly List<ICharacter> _groupMembers;
        private readonly Dictionary<IAbility, DateTime> _cooldowns; // Key: ability.Id, Value: Next ability availability
        private readonly List<AbilityAndLevel> _knownAbilities;
        private readonly List<IQuest> _quests;

        protected int MaxHitPoints => _secondaryAttributes[(int) SecondaryAttributeTypes.MaxHitPoints];

        private Character(Guid guid, string name, string description)
            : base(guid, name, description)
        {
            _fullCommands = new Trie<CommandMethodInfo>();
            _inventory = new List<IItem>();
            _equipments = new List<EquipedItem>();
            _periodicAuras = new List<IPeriodicAura>();
            _auras = new List<IAura>();
            _basePrimaryAttributes = new int[EnumHelpers.GetCount<PrimaryAttributeTypes>()];
            _currentPrimaryAttributes = new int[EnumHelpers.GetCount<PrimaryAttributeTypes>()];
            _secondaryAttributes = new int[EnumHelpers.GetCount<SecondaryAttributeTypes>()];
            _maxResources = new int[EnumHelpers.GetCount<ResourceKinds>()];
            _currentResources = new int[EnumHelpers.GetCount<ResourceKinds>()];
            _groupMembers = new List<ICharacter>();
            _cooldowns = new Dictionary<IAbility, DateTime>(new CompareIAbility());
            _quests = new List<IQuest>();
            _knownAbilities = new List<AbilityAndLevel>(); // handled by RecomputeKnownAbilities

            Position = Positions.Standing;
            Form = Forms.Normal;
        }

        public Character(Guid guid, CharacterData data, IRoom room)
            : this(guid, data.Name, string.Empty)
        {
            Class = ClassManager[data.Class];
            if (Class == null)
            {
                string msg = $"Invalid class {data.Class} for character {data.Name}!!";
                Log.Default.WriteLine(LogLevels.Error, msg);
                Class = ClassManager.Classes.First();
                Server.Wiznet(msg, WiznetFlags.Bugs, AdminLevels.Implementor);
            }
            Race = RaceManager[data.Race];
            if (Race == null)
            {
                string msg = $"Invalid race {data.Race} for character {data.Name}!!";
                Log.Default.WriteLine(LogLevels.Error, msg);
                Race = RaceManager.Races.First();
                Server.Wiznet(msg, WiznetFlags.Bugs, AdminLevels.Implementor);
            }
            Sex = data.Sex;
            Level = data.Level;
            Experience = data.Experience;

            Impersonable = true; // Playable
            Room = room;
            room.Enter(this);

            RecomputeBaseAttributes();
            RecomputeKnownAbilities();
            ResetAttributes(true);
            RecomputeCommands();
            RecomputeCurrentResourceKinds();
            BuildEquipmentSlots();
        }

        public Character(Guid guid, CharacterBlueprint blueprint, IRoom room) // NPC
            : this(guid, blueprint.Name, blueprint.Description)
        {
            Blueprint = blueprint;

            // TODO: mob class/race ???
            Sex = blueprint.Sex;
            Level = blueprint.Level;
            Experience = CombatHelpers.ExperienceToNextLevel.Where(x => x.Key < Level).Sum(x => x.Value);

            Impersonable = false; // Non-playable
            Room = room;
            room.Enter(this);

            RecomputeBaseAttributes();
            RecomputeKnownAbilities();
            ResetAttributes(true);
            RecomputeCommands();
            RecomputeCurrentResourceKinds();
            BuildEquipmentSlots();
        }

        #region ICharacter

        #region IEntity

        #region IActor

        public override IReadOnlyTrie<CommandMethodInfo> Commands => _fullCommands;

        public override void Send(string message, bool addTrailingNewLine)
        {
            // TODO: use Act formatter ?
            base.Send(message, addTrailingNewLine);
            if (ImpersonatedBy != null)
            {
                if (ServerOptions.PrefixForwardedMessages)
                    message = "<IMP|" + DisplayName + ">" + message;
                ImpersonatedBy.Send(message, addTrailingNewLine);
            }
            // TODO: do we really need to receive message sent to slave ?
            if (ServerOptions.ForwardSlaveMessages && ControlledBy != null)
            {
                if (ServerOptions.PrefixForwardedMessages)
                    message = "<CTRL|" + DisplayName + ">" + message;
                ControlledBy.Send(message, addTrailingNewLine);
            }
        }

        public override void Page(StringBuilder text)
        {
            base.Page(text);
            ImpersonatedBy?.Page(text);
            if (ServerOptions.ForwardSlaveMessages && ControlledBy != null)
                ControlledBy.Page(text);
        }

        #endregion

        public override string DisplayName => Blueprint == null ? StringHelpers.UpperFirstLetter(Name) : Blueprint.ShortDescription;

        public override string DebugName => Blueprint == null ? DisplayName : $"{DisplayName}[{Blueprint.Id}]";

        public override string RelativeDisplayName(ICharacter beholder, bool capitalizeFirstLetter = false)
        {
            StringBuilder displayName = new StringBuilder();
            if (IsQuestObjective(beholder))
                displayName.Append(StringHelpers.QuestPrefix);
            if (beholder.CanSee(this))
                displayName.Append(DisplayName);
            else if (capitalizeFirstLetter)
                displayName.Append("Someone");
            else
                displayName.Append("someone");
            return displayName.ToString();
        }

        // TODO: override RelativeDescription ?

        public override void OnRemoved() // called before removing a character from the game
        {
            base.OnRemoved();

            StopFighting(true);
            Slave?.ChangeController(null);
            // TODO: what if character is incarnated
            ImpersonatedBy?.StopImpersonating();
            ImpersonatedBy = null; // TODO: warn ImpersonatedBy ?
            ControlledBy = null; // TODO: warn ControlledBy ?
            Leader = null; // TODO: warn Leader
            _inventory.Clear();
            _equipments.Clear();
            Blueprint = null;
            Room = null;
        }

        #endregion

        #region IContainer

        public IEnumerable<IItem> Content => _inventory.Where(x => x.IsValid);

        public bool PutInContainer(IItem obj)
        {
            // TODO: check if already in a container
            _inventory.Insert(0, obj);
            return true;
        }

        public bool GetFromContainer(IItem obj)
        {
            bool removed = _inventory.Remove(obj);
            return removed;
        }

        #endregion

        public CharacterBlueprint Blueprint { get; private set; }

        public IRoom Room { get; private set; }

        public ICharacter Fighting { get; private set; }

        public IEnumerable<EquipedItem> Equipments => _equipments;

        // Furniture (sleep/sit/stand)
        public IItemFurniture Furniture { get; private set; }

        // Position
        public Positions Position { get; private set; }

        // Class/Race
        public IClass Class { get; }
        public IRace Race { get; }

        // Attributes
        public Sex Sex { get; }
        public long Experience { get; private set; }
        public int Level { get; private set; }
        public int HitPoints { get; private set; }

        public int this[ResourceKinds resource]
        {
            get => _currentResources[(int) resource];
            private set => _currentResources[(int) resource] = value;
        }

        public int this[PrimaryAttributeTypes attribute]
        {
            get => _currentPrimaryAttributes[(int) attribute];
            private set => _currentPrimaryAttributes[(int) attribute] = value;
        }

        public int this[SecondaryAttributeTypes attribute]
        {
            get => _secondaryAttributes[(int) attribute];
            private set => _secondaryAttributes[(int) attribute] = value;
        }

        public IEnumerable<ResourceKinds> CurrentResourceKinds { get; private set; }

        public long ExperienceToLevel => 
            Level >= ServerOptions.MaxLevel
                ? 0
                : CombatHelpers.CumulativeExperienceByLevel[Level] + CombatHelpers.ExperienceToNextLevel[Level] - Experience;

        // Form
        public Forms Form { get; private set; }

        // Abilities

        public IEnumerable<AbilityAndLevel> KnownAbilities => _knownAbilities;

        // Periodic Auras
        public IEnumerable<IPeriodicAura> PeriodicAuras => _periodicAuras;

        public IEnumerable<IAura> Auras => _auras;

        public ICharacter Leader { get; private set; }

        public IEnumerable<ICharacter> GroupMembers => _groupMembers.Where(x => x.IsValid);

        // Impersonation/Controller
        public bool Impersonable { get; }
        public IPlayer ImpersonatedBy { get; private set; }

        public ICharacter Slave { get; private set; } // who is our slave (related to charm command/spell)
        public ICharacter ControlledBy { get; private set; } // who is our master (related to charm command/spell)

        // Quest
        public IEnumerable<IQuest> Quests => _quests;

        public void AddQuest(IQuest quest)
        {
            // TODO: max quest ?
            _quests.Add(quest);
        }

        public void CompleteQuest(IQuest quest)
        {
            if (_quests.All(q => q.Blueprint.Id != quest.Blueprint.Id))
            {
                Log.Default.WriteLine(LogLevels.Warning, $"ICharacter.CompleteQuest: unassigned quest {quest.Blueprint.Id} for {DebugName}");
                return;
            }
            if (!quest.IsCompleted)
            {
                Send("Quest {0} is not finished!", quest.Blueprint.Title);
                return;
            }
            Send("You complete {0} successfully.", quest.Blueprint.Title);

            quest.Complete();
            _quests.Remove(quest);
        }

        public void AbandonQuest(IQuest quest)
        {
            if (_quests.All(q => q.Blueprint.Id != quest.Blueprint.Id))
            {
                Log.Default.WriteLine(LogLevels.Warning, $"ICharacter.CompleteQuest: unassigned quest {quest.Blueprint.Id} for {DebugName}");
                return;
            }
            Send("You abandon {0}!", quest.Blueprint.Title);
            quest.Abandon();
            _quests.Remove(quest);
        }

        public bool IsQuestObjective(ICharacter questingCharacter)
        {
            // If 'this' is NPC and in object list or in kill loot table
            return !Impersonable && Blueprint != null
                   && (questingCharacter.Quests.Where(q => !q.IsCompleted).SelectMany(q => q.Objectives).OfType<KillQuestObjective>().Any(o => o.Blueprint.Id == Blueprint.Id)
                       || questingCharacter.Quests.Where(q => !q.IsCompleted).Any(q => q.Blueprint.KillLootTable.ContainsKey(Blueprint.Id)));
        }

        // Group
        public bool ChangeLeader(ICharacter newLeader)
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.ChangeLeader: {0} is not valid anymore", DebugName);
                return false;
            }
            if (newLeader != null && !newLeader.IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.ChangeLeader: {0} is not valid anymore", newLeader.DebugName);
                return false;
            }
            Log.Default.WriteLine(LogLevels.Debug, "ICharacter.ChangeLeader: {0} old= {1}; new {2}", DebugName, Leader == null ? "<<none>>" : Leader.DebugName, newLeader == null ? "<<none>>" : newLeader.DebugName);
            Leader = newLeader;
            return true;
        }

        public bool AddGroupMember(ICharacter newMember, bool silent)
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.AddGroupMember: {0} is not valid anymore", DebugName);
                return false;
            }
            if (Leader != null)
            {
                Log.Default.WriteLine(LogLevels.Warning, "ICharacter.AddGroupMember: {0} cannot add member because leader is not null", DebugName);
                return false;
            }
            if (!newMember.IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.AddGroupMember: new member {0} is not valid anymore");
                return false;
            }
            if (_groupMembers.Any(x => x == newMember))
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.AddGroupMember: {0} already in group of {1}", newMember.DebugName, DebugName);
                return false;
            }
            Log.Default.WriteLine(LogLevels.Debug, "ICharacter.AddGroupMember: {0} joined by {1}", DebugName, newMember.DebugName);
            // TODO: act to warn room ?
            if (!silent)
                Send("{0} joins group.", newMember.DisplayName);
            newMember.ChangeLeader(this); // this is not mandatory (should be done by caller)
            if (!silent)
                foreach (ICharacter member in _groupMembers)
                    member.Send("{0} joins group.", newMember.DisplayName);
            if (!silent)
                newMember.Act(ActOptions.ToCharacter, "You join {0}'s group.", this);
            _groupMembers.Add(newMember);
            return true;
        }

        public bool RemoveGroupMember(ICharacter oldMember, bool silent) // TODO: what if leader leaves group!!!
        {
            Log.Default.WriteLine(LogLevels.Debug, "ICharacter.RemoveGroupMember: {0} leaves {1}", oldMember.DebugName, DebugName);
            bool removed = _groupMembers.Remove(oldMember);
            if (!removed)
            {
                Log.Default.WriteLine(LogLevels.Debug, "ICharacter.RemoveGroupMember: {0} not in group of {1}", oldMember.DebugName, DebugName);
                return false;
            }
            oldMember.ChangeLeader(null); // this is not mandatory (should be done by caller)
            if (!silent)
                Send("{0} leaves group.", oldMember.DebugName);
            // TODO: act to warn room ?
            if (!silent)
                foreach (ICharacter member in _groupMembers)
                    member.Send("{0} leaves group.", member.DebugName);
            if (!silent)
                oldMember.Act(ActOptions.ToCharacter, "You leave {0}'s group.", this);
            return true;
        }

        public bool AddFollower(ICharacter follower)
        {
            follower.ChangeLeader(this);
            if (CanSee(follower))
                Act(ActOptions.ToCharacter, "{0} now follows you.", follower);
            follower.Act(ActOptions.ToCharacter, "You now follow {0}.", this);
            return true;
        }

        public bool StopFollower(ICharacter follower)
        {
            if (follower.Leader == null)
            {
                Log.Default.WriteLine(LogLevels.Warning, "ICharacter:StopFollower: {0} is not following anyone", follower.DebugName);
                return false;
            }
            if (follower.Leader != this)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter:StopFollower: {0} is not following {1} but {2}", follower.DebugName, DebugName, follower.Leader == null ? "<<none>>" : follower.Leader.DebugName);
                return false;
            }
            follower.ChangeLeader(null);
            if (CanSee(follower))
                Act(ActOptions.ToCharacter, "{0} stops following you.", follower);
            follower.Act(ActOptions.ToCharacter, "You stop following {0}.", this);
            return true;
        }

        // Impersonation/Controller
        public bool ChangeImpersonation(IPlayer player) // if non-null, start impersonation, else, stop impersonation
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.ChangeImpersonation: {0} is not valid anymore", DebugName);
                ImpersonatedBy = null;
                return false;
            }

            Log.Default.WriteLine(LogLevels.Debug, "ICharacter.ChangeImpersonation: {0} old: {1}; new {2}", DebugName, ImpersonatedBy == null ? "<<none>>" : ImpersonatedBy.DisplayName, player == null ? "<<none>>" : player.DisplayName);
            // TODO: check if not already impersonated, if impersonable, ...
            ImpersonatedBy = player;
            RecomputeKnownAbilities();
            RecomputeAttributes();
            RecomputeCommands();
            return true;
        }

        public override bool ChangeIncarnation(IAdmin admin)
        {
            bool result = base.ChangeIncarnation(admin);
            if (result)
            {
                RecomputeKnownAbilities();
                RecomputeAttributes();
                RecomputeCommands();
            }
            return result;
        }

        public bool ChangeController(ICharacter master) // if non-null, start slavery, else, stop slavery
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.ChangeController: {0} is not valid anymore", DebugName);
                return false;
            }

            Log.Default.WriteLine(LogLevels.Debug, "ICharacter.ChangeController: {0} master: old: {1}; new {2}", DebugName, ControlledBy == null ? "<<none>>" : ControlledBy.DebugName, master == null ? "<<none>>" : master.DebugName);
            // TODO: check if already slave, ...
            if (master == null) // TODO: remove display ???
            {
                if (ControlledBy != null)
                {
                    Act(ActOptions.ToCharacter, "You stop following {0}.", ControlledBy);
                    ControlledBy.Act(ActOptions.ToCharacter, "{0} stops following you.", this);
                }
            }
            else
            {
                Act(ActOptions.ToCharacter, "You now follow {0}.", master);
                master.Act(ActOptions.ToCharacter, "{0} now follows you.", this);
            }
            ControlledBy = master;
            return true;
        }

        // Act
        // IFormattable cannot be used because formatting depends on who'll receive the message (CanSee check)
        public void Act(ActOptions option, string format, params object[] arguments)
        {
            IEnumerable<ICharacter> targets;
            switch (option)
            {
                case ActOptions.ToAll:
                    targets = Room.People;
                    break;
                case ActOptions.ToRoom:
                    targets = Room.People.Where(x => x != this);
                    break;
                case ActOptions.ToGroup:
                    if (Leader != null)
                        targets = Leader.GroupMembers; // !! GroupMembers doesn't include Leader
                    else
                        return; // NOP
                    break;
                case ActOptions.ToCharacter:
                    targets = Enumerable.Repeat(this, 1);
                    break;
                default:
                    Log.Default.WriteLine(LogLevels.Error, "Act with invalid option: {0}", option);
                    return; //
            }
            foreach (ICharacter target in targets)
            {
                // TODO: optimization ?  FormatActOneLine will always return the same string for every target different than 'this' --> no anymore true with QuestObjective
                string phrase = FormatActOneLine(target, format, arguments);
                target.Send(phrase);
            }
        }

        public void ActToNotVictim(ICharacter victim, string format, params object[] arguments) // to everyone except this and victim
        {
            foreach (ICharacter to in Room.People.Where(x => x != this && x != victim))
            {
                string phrase = FormatActOneLine(to, format, arguments);
                to.Send(phrase);
            }
        }

        public void Act(IEnumerable<ICharacter> characters, string format, params object[] arguments)
        {
            foreach (ICharacter target in characters)
            {
                string phrase = FormatActOneLine(target, format, arguments);
                target.Send(phrase);
            }
        }

        // Equipments
        public bool Unequip(IEquipable item)
        {
            foreach (EquipedItem equipmentSlot in _equipments.Where(x => x.Item == item))
                equipmentSlot.Item = null;
            RecomputeAttributes();
            return true;
        }

        // Furniture
        public bool ChangeFurniture(IItemFurniture furniture)
        {
            Furniture = furniture;
            return true;
        }

        // Position
        public bool ChangePosition(Positions position)
        {
            // TODO: false in some cases ?
            Position = position;
            return true;
        }

        // Visibility
        public bool CanSee(ICharacter target)
        {
            return true; // TODO: invis/sneak/blind
        }

        public bool CanSee(IItem target)
        {
            if (target is IItemQuest questItem)
            {
                // See only if on this quest
                if (Quests.Any(x => x.Objectives.OfType<ItemQuestObjective>().Any(o => o.Blueprint.Id == questItem.Blueprint.Id)))
                    return true;
                return false;
            }
            return true; // TODO: invis/blind
        }

        public bool CanSee(IExit exit)
        {
            return true; // TODO: Hidden
        }

        // Attributes
        public int GetBasePrimaryAttribute(PrimaryAttributeTypes attribute) => _basePrimaryAttributes[(int) attribute];

        public int GetMaxResource(ResourceKinds resource) => _maxResources[(int) resource];

        public void ChangeResource(ResourceKinds resource, int amount)
        {
            this[resource] = Math.Min(_maxResources[(int) resource], Math.Max(0, this[resource] + amount));
        }

        public void UpdateResources()
        {
            // TODO: use real formulas (rage decrease and other increase)
            if (HitPoints < MaxHitPoints)
            {
                int regen = MaxHitPoints/20;
                if (Furniture?.HealBonus > 0)
                    regen = (regen*Furniture.HealBonus)/100;
                HitPoints = Math.Min(MaxHitPoints,HitPoints + regen);
            }
            foreach (ResourceKinds resource in EnumHelpers.GetValues<ResourceKinds>())
            {
                int max = GetMaxResource(resource);
                int current = this[resource];
                if (current < max)
                {
                    int regen = max/20; // base value:  // + 5% of max value
                    if (Furniture?.ResourceBonus > 0)
                        regen = (regen * Furniture.ResourceBonus) / 100;
                    current += regen;
                }
                this[resource] = Math.Min(max, Math.Max(0, current)); // keep value in valid range
            }
        }

        // Form
        public bool ChangeForm(Forms form)
        {
            if (form == Form)
                return false;

            if (form == Forms.Normal)
                Send("You regain your normal form");

            Form = form;

            RecomputeKnownAbilities();
            RecomputeAttributes();
            RecomputeCommands();
            RecomputeCurrentResourceKinds();

            // Start values
            this[ResourceKinds.Energy] = 100;
            this[ResourceKinds.Rage] = 0;
            this[ResourceKinds.Runic] = 0;

            return true;
        }

        // Auras
        public void AddPeriodicAura(IPeriodicAura aura)
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.AddPeriodicAura: {0} is not valid anymore", DebugName);
                return;
            }
            //IPeriodicAura same = _periodicAuras.FirstOrDefault(x => ReferenceEquals(x.Ability, aura.Ability) && x.AuraType == aura.AuraType && x.School == aura.School && x.Source == aura.Source);
            IPeriodicAura same = _periodicAuras.FirstOrDefault(x => x.Ability == aura.Ability && x.AuraType == aura.AuraType && x.School == aura.School && x.Source == aura.Source);
            if (same != null)
            {
                Log.Default.WriteLine(LogLevels.Info, "ICharacter.AddPeriodicAura: Refresh: {0} {1}", DebugName, aura.Ability == null ? "<<??>>" : aura.Ability.Name);
                same.Refresh(aura);
            }
            else
            {
                Log.Default.WriteLine(LogLevels.Info, "ICharacter.AddPeriodicAura: Add: {0} {1}", DebugName, aura.Ability == null ? "<<??>>" : aura.Ability.Name);
                _periodicAuras.Add(aura);
                if (aura.Ability == null || (aura.Ability.Flags & AbilityFlags.AuraIsHidden) != AbilityFlags.AuraIsHidden)
                    Send("You are now affected by {0}.", aura.Ability == null ? "Something" : aura.Ability.Name);
                if (aura.Source != null && aura.Source != this)
                {
                    if (aura.Ability == null || (aura.Ability.Flags & AbilityFlags.AuraIsHidden) != AbilityFlags.AuraIsHidden)
                        aura.Source.Act(ActOptions.ToCharacter, "{0} is now affected by {1}", this, aura.Ability == null ? "Something" : aura.Ability.Name);
                    if (aura.AuraType == PeriodicAuraTypes.Damage)
                    {
                        if (Fighting == null)
                            StartFighting(aura.Source);
                        if (aura.Source.Fighting == null)
                            aura.Source.StartFighting(this);
                    }
                }
            }
        }

        public void RemovePeriodicAura(IPeriodicAura aura)
        {
            Log.Default.WriteLine(LogLevels.Info, "ICharacter.RemovePeriodicAura: {0} {1}", DebugName, aura.Ability == null ? "<<??>>" : aura.Ability.Name);
            bool removed = _periodicAuras.Remove(aura);
            if (!removed)
                Log.Default.WriteLine(LogLevels.Warning, "ICharacter.RemovePeriodicAura: Trying to remove unknown PeriodicAura");
            else
            {
                if (aura.Ability == null || (aura.Ability.Flags & AbilityFlags.AuraIsHidden) != AbilityFlags.AuraIsHidden)
                {
                    Send("{0} vanishes.", aura.Ability == null ? "Something" : aura.Ability.Name);
                    if (aura.Source != null && aura.Source != this)
                        aura.Source.Act(ActOptions.ToCharacter, "{0} vanishes on {1}.", aura.Ability == null ? "Something" : aura.Ability.Name, this);
                }
                aura.ResetSource();
            }
        }

        public void AddAura(IAura aura, bool recompute)
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.AddAura: {0} is not valid anymore", DebugName);
                return;
            }
            //IAura same = _auras.FirstOrDefault(x => ReferenceEquals(x.Ability, aura.Ability) && x.Modifier == aura.Modifier && x.Source == aura.Source);
            IAura same = _auras.FirstOrDefault(x => x.Ability == aura.Ability && x.Modifier == aura.Modifier && x.Source == aura.Source);
            if (same != null)
            {
                Log.Default.WriteLine(LogLevels.Info, "ICharacter.AddAura: Refresh: {0} {1}| recompute: {2}", DebugName, aura.Ability == null ? "<<??>>" : aura.Ability.Name, recompute);
                same.Refresh(aura);
            }
            else
            {
                Log.Default.WriteLine(LogLevels.Info, "ICharacter.AddAura: Add: {0} {1}| recompute: {2}", DebugName, aura.Ability == null ? "<<??>>" : aura.Ability.Name, recompute);
                _auras.Add(aura);
                if (aura.Ability == null || (aura.Ability.Flags & AbilityFlags.AuraIsHidden) != AbilityFlags.AuraIsHidden)
                    Send("You are now affected by {0}.", aura.Ability == null ? "Something" : aura.Ability.Name);
            }
            if (recompute)
                RecomputeAttributes();
        }

        public void RemoveAura(IAura aura, bool recompute)
        {
            Log.Default.WriteLine(LogLevels.Info, "ICharacter.RemoveAura: {0} {1} | recompute: {2}", DebugName, aura.Ability == null ? "<<??>>" : aura.Ability.Name, recompute);
            bool removed = _auras.Remove(aura);
            if (!removed)
                Log.Default.WriteLine(LogLevels.Warning, "ICharacter.RemoveAura: Trying to remove unknown aura");
            else if (aura.Ability == null || (aura.Ability.Flags & AbilityFlags.AuraIsHidden) != AbilityFlags.AuraIsHidden)
                Send("{0} vanishes.", aura.Ability == null ? "Something" : aura.Ability.Name);
            if (recompute && removed)
                RecomputeAttributes();
        }

        // Recompute
        public void Reset() // Reset attributes, remove auras, periodic auras
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ResetAttributes: {0} is not valid anymore", DebugName);
                return;
            }

            // Remove periodic auras on character
            _periodicAuras.Clear();
            _auras.Clear();

            ResetAttributes(true);
        }

        public void ResetAttributes(bool resetHitPoints)
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ResetAttributes: {0} is not valid anymore", DebugName);
                return;
            }

            RecomputeAttributes();

            if (resetHitPoints)
                HitPoints = MaxHitPoints;
            foreach (ResourceKinds resource in EnumHelpers.GetValues<ResourceKinds>())
                this[resource] = _maxResources[(int) resource];
            //this[resource] = 10; // TEST
        }

        public void RecomputeAttributes()
        {
            // Reset current attributes
            for (int i = 0; i < _currentPrimaryAttributes.Length; i++)
                _currentPrimaryAttributes[i] = _basePrimaryAttributes[i];
            // Apply auras on primary attributes
            // TODO: aura from equipment/room/group
            foreach (IAura aura in Auras)
            {
                switch (aura.Modifier)
                {
                    case AuraModifiers.Strength:
                        ModifyAttribute(PrimaryAttributeTypes.Strength, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.Agility:
                        ModifyAttribute(PrimaryAttributeTypes.Agility, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.Stamina:
                        ModifyAttribute(PrimaryAttributeTypes.Stamina, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.Intellect:
                        ModifyAttribute(PrimaryAttributeTypes.Intellect, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.Spirit:
                        ModifyAttribute(PrimaryAttributeTypes.Spirit, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.Characteristics:
                        ModifyAttribute(PrimaryAttributeTypes.Strength, aura.AmountOperator, aura.Amount);
                        ModifyAttribute(PrimaryAttributeTypes.Agility, aura.AmountOperator, aura.Amount);
                        ModifyAttribute(PrimaryAttributeTypes.Stamina, aura.AmountOperator, aura.Amount);
                        ModifyAttribute(PrimaryAttributeTypes.Intellect, aura.AmountOperator, aura.Amount);
                        ModifyAttribute(PrimaryAttributeTypes.Spirit, aura.AmountOperator, aura.Amount);
                        break;
                }

            }
            // Recompute datas depending on attributes and abilities
            // TODO: correct formulas
            this[SecondaryAttributeTypes.MaxHitPoints] = this[PrimaryAttributeTypes.Stamina]*50 + 1000;
            this[SecondaryAttributeTypes.AttackPower] = this[PrimaryAttributeTypes.Strength]*2 + 50;
            this[SecondaryAttributeTypes.SpellPower] = this[PrimaryAttributeTypes.Intellect] + 50;
            this[SecondaryAttributeTypes.Critical] = 5;
            this[SecondaryAttributeTypes.Dodge] = 3;
            this[SecondaryAttributeTypes.Parry] = 10;
            this[SecondaryAttributeTypes.Block] = 5;
            this[SecondaryAttributeTypes.AttackSpeed] = 20;
            this[SecondaryAttributeTypes.Armor] = ComputeArmorFromEquipments();
            //
            // Recompute max resources
            // TODO: correct values
            _maxResources[(int) ResourceKinds.Mana] = Level*2000;
            _maxResources[(int) ResourceKinds.Energy] = 100;
            _maxResources[(int) ResourceKinds.Rage] = 100;
            _maxResources[(int) ResourceKinds.Runic] = 120;
            // TODO: runes
            // Apply aura on compute attributes
            foreach (IAura aura in Auras)
            {
                switch (aura.Modifier)
                {
                    case AuraModifiers.MaxHitPoints:
                        ModifyAttribute(SecondaryAttributeTypes.MaxHitPoints, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.AttackPower:
                        ModifyAttribute(SecondaryAttributeTypes.AttackPower, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.SpellPower:
                        ModifyAttribute(SecondaryAttributeTypes.SpellPower, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.AttackSpeed:
                        ModifyAttribute(SecondaryAttributeTypes.AttackSpeed, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.Armor:
                        ModifyAttribute(SecondaryAttributeTypes.Armor, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.Critical:
                        ModifyAttribute(SecondaryAttributeTypes.Critical, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.Dodge:
                        ModifyAttribute(SecondaryAttributeTypes.Dodge, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.Parry:
                        ModifyAttribute(SecondaryAttributeTypes.Parry, aura.AmountOperator, aura.Amount);
                        break;
                    case AuraModifiers.Block:
                        ModifyAttribute(SecondaryAttributeTypes.Block, aura.AmountOperator, aura.Amount);
                        break;
                }
            }
            // Keep attributes in valid range
            HitPoints = Math.Min(HitPoints, MaxHitPoints);
            // TODO: keep other attributes in valid range
        }

        // Move
        public bool Move(ExitDirections direction, bool checkFighting, bool follow = false)
        {
            IRoom fromRoom = Room;
            IExit exit = fromRoom.Exit(direction);
            IRoom toRoom = exit?.Destination;

            // TODO: act_move.C:133
            // cannot move while in combat -> should be handled by POSITION in command
            // drunk
            // exit flags such as climb, door closed, ...
            // private room, size, swim room, guild room

            if (checkFighting && Fighting != null)
                Send("No way! You are still fighting!");
            else if (ControlledBy != null && ControlledBy.Room == Room) // Slave cannot leave a room without Master
                Send("What?  And leave your beloved master?");
            else if (exit == null || toRoom == null) // Check if existing exit
            {
                Send("You almost goes {0}, but suddenly realize that there's no exit there.", direction);
                Act(ActOptions.ToRoom, "{0} looks like {0:e}'s about to go {1}, but suddenly stops short and looks confused.", this, direction);
            }
            else if (exit.IsClosed)
                Act(ActOptions.ToCharacter, "The {0} is closed.", exit);
            else
            {
                Act(ActOptions.ToRoom, "{0} leaves {1}.", this, direction); // TODO: sneak/invis

                SetGlobalCooldown(1);
                ChangeRoom(toRoom);

                // Autolook if impersonated/incarnated
                if (ImpersonatedBy != null || IncarnatedBy != null)
                    DisplayRoom();

                Act(ActOptions.ToRoom, "{0} has arrived.", this); // TODO: sneak/invis

                // Followers: no circular follows
                if (fromRoom != toRoom)
                {
                    if (Slave != null)
                    {
                        Slave.Send("You follow {0}.", DebugName);
                        Slave.Move(direction, true);
                    }
                    IReadOnlyCollection<ICharacter> followers = new ReadOnlyCollection<ICharacter>(fromRoom.People.Where(x => x.Leader == this).ToList()); // clone because Move will modify fromRoom.People
                    foreach (ICharacter follower in followers)
                    {
                        follower.Send("You follow {0}.", DebugName);
                        follower.Move(direction, true);
                    }
                }
            }
            return true;
        }

        public bool Enter(IItemPortal portal, bool follow = false)
        {
            IRoom destination = portal?.Destination;
            if (portal == null || destination == null || destination == Room)
            {
                Act(ActOptions.ToCharacter, "{0} doesn't seem to go anywhere.");
                return true;
            }

            IRoom wasRoom = Room;

            Act(ActOptions.ToRoom, "{0:N} steps into {1}.", this, portal);
            Act(ActOptions.ToCharacter, "You walk through {0} and find yourself somewhere else...", portal);

            ChangeRoom(destination);

            if (ImpersonatedBy != null || IncarnatedBy != null)
                DisplayRoom();

            Act(ActOptions.ToRoom, "{0:N} arrived through {1}.", this, portal);

            // Followers: no circular follows
            if (wasRoom != destination)
            {
                if (Slave != null)
                {
                    Slave.Send("You follow {0}.", DebugName);
                    Slave.Enter(portal, true);
                }
                IReadOnlyCollection<ICharacter> followers = new ReadOnlyCollection<ICharacter>(wasRoom.People.Where(x => x.Leader == this).ToList()); // clone because Move will modify fromRoom.People
                foreach (ICharacter follower in followers)
                {
                    follower.Send("You follow {0}.", DebugName);
                    follower.Enter(portal, true);
                }
            }

            return true;
        }

        public void ChangeRoom(IRoom destination)
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.ChangeRoom: {0} is not valid anymore", DebugName);
                return;
            }

            Log.Default.WriteLine(LogLevels.Debug, "ICharacter.ChangeRoom: {0} from: {1} to {2}", DebugName, Room == null ? "<<no room>>" : Room.DebugName, destination == null ? "<<no room>>" : destination.DebugName);
            Room?.Leave(this);
            Room = destination;
            destination?.Enter(this);
        }

        // Combat
        public bool Heal(ICharacter source, IAbility ability, int amount, bool visible)
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.Heal: {0} is not valid anymore", DebugName);
                return false;
            }

            // Modify heal (resist, vuln, invul, absorb)
            bool fullyAbsorbed;
            amount = ModifyHeal(amount, out fullyAbsorbed);

            Log.Default.WriteLine(LogLevels.Info, "{0} healed by {1} {2} for {3}", DebugName, source == null ? "<<??>>" : source.DebugName, ability == null ? "<<??>>" : ability.Name, amount);
            if (amount <= 0)
                Log.Default.WriteLine(LogLevels.Warning, "ICharacter.Heal: invalid amount {0} on {1}", amount, DebugName);
            else
                HitPoints = Math.Min(HitPoints + amount, MaxHitPoints);

            Log.Default.WriteLine(LogLevels.Debug, "{0} HP left: {1}", DebugName, HitPoints);

            // Display heal
            if (visible)
            {
                if (fullyAbsorbed)
                    DisplayHealAbsorbPhrase(ability?.Name ?? "Something", source);
                else
                    DisplayHealPhrase(ability, amount, source);
            }

            return true;
        }

        public bool MultiHit(ICharacter enemy)
        {
            // TODO: read http://wowwiki.wikia.com/wiki/Combat
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "ICharacter.MultiHit: {0} is not valid anymore", DebugName);
                return false;
            }

            if (!IsValid)
                return false;

            Log.Default.WriteLine(LogLevels.Debug, "ICharacter.MultiHit: {0} -> {1}", DebugName, enemy.DebugName);

            if (this == enemy || Room != enemy.Room)
                return false;

            // TODO: more haste -> more attacks (should depend on weapon speed, attack speed, server speed[PulseViolence])

            // TODO: TEST purpose
            //int attackCount = Math.Max(1, 1 + this[SecondaryAttributeTypes.AttackSpeed] / 21);
            int attackCount = Math.Max(1, 1 + this[SecondaryAttributeTypes.AttackSpeed]);

            // Main hand or Wield2H
            for (int i = 0; i < attackCount; i++)
            {
                // Cannot store wielded between hit (disarm anyone ?)
                IItemWeapon wielded = (Equipments.FirstOrDefault(x => x.Slot == EquipmentSlots.Wield) ?? Equipments.FirstOrDefault(x => x.Slot == EquipmentSlots.Wield2H) ?? EquipedItem.NullObject).Item as IItemWeapon;
                SchoolTypes damageType = wielded?.DamageType ?? SchoolTypes.Physical;
                OneHit(enemy, wielded, damageType, false);

                if (Fighting != enemy) // stop multihit if different enemy or no enemy
                    return true;
            }

            // Off hand
            if (KnownAbilities.Any(x => x.Ability == AbilityManager.DualWieldAbility))
            {
                IItemWeapon wielded2 = (Equipments.FirstOrDefault(x => x.Slot == EquipmentSlots.Wield2) ?? EquipedItem.NullObject).Item as IItemWeapon;
                if (wielded2 == null)
                    return true;
                OneHit(enemy, wielded2, wielded2.DamageType, true);
            }
            if (Fighting != enemy) // stop multihit if different enemy or no enemy
                return true;

            // 3rd hand or Wield2H2
            if (KnownAbilities.Any(x => x.Ability == AbilityManager.ThirdWieldAbility))
            {
                IItemWeapon wielded3 = (Equipments.FirstOrDefault(x => x.Slot == EquipmentSlots.Wield3) ?? Equipments.FirstOrDefault(x => x.Slot == EquipmentSlots.Wield2H2) ?? EquipedItem.NullObject).Item as IItemWeapon;
                if (wielded3 == null)
                    return true;
                OneHit(enemy, wielded3, wielded3.DamageType, true);
            }
            if (Fighting != enemy) // stop multihit if different enemy or no enemy
                return true;

            // 4th hand
            if (KnownAbilities.Any(x => x.Ability == AbilityManager.FourthWieldAbility))
            {
                IItemWeapon wielded4 = (Equipments.FirstOrDefault(x => x.Slot == EquipmentSlots.Wield4) ?? EquipedItem.NullObject).Item as IItemWeapon;
                if (wielded4 == null)
                    return true;
                OneHit(enemy, wielded4, wielded4.DamageType, true);
            }
            if (Fighting != enemy) // stop multihit if different enemy or no enemy
                return true;

            return true;
        }

        public bool StartFighting(ICharacter enemy) // equivalent to set_fighting in fight.C:3441
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "StartFighting: {0} is not valid anymore", DebugName);
                return false;
            }

            Log.Default.WriteLine(LogLevels.Debug, "{0} starts fighting {1}", DebugName, enemy.DebugName);

            ChangePosition(Positions.Fighting);
            Fighting = enemy;
            return true;
        }

        public bool StopFighting(bool both) // equivalent to stop_fighting in fight.C:3441
        {
            Log.Default.WriteLine(LogLevels.Debug, "{0} stops fighting {1}", Name, Fighting == null ? "<<no enemy>>" : Fighting.Name);

            Fighting = null;
            ChangePosition(Positions.Standing);
            if (both)
            {
                foreach (ICharacter enemy in World.Characters.Where(x => x.Fighting == this))
                    enemy.StopFighting(false);
            }
            return true;
        }

        public bool WeaponDamage(ICharacter source, IItemWeapon weapon, int damage, SchoolTypes damageType, bool visible) // damage from weapon(or bare hands) of known source
        {
            return GenericDamage(source, weapon?.DisplayName, damage, damageType, visible);
        }

        public bool AbilityDamage(ICharacter source, IAbility ability, int damage, SchoolTypes damageType, bool visible) // damage from ability of known source
        {
            return GenericDamage(source, ability?.Name, damage, damageType, visible);
        }

        public bool UnknownSourceDamage(IAbility ability, int damage, SchoolTypes damageType, bool visible) // damage with unknown source or no source
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "UnknownSourceDamage: {0} is not valid anymore", DebugName);
                return false;
            }

            // Modify damage (resist, vuln, invul, absorb)
            bool fullyAbsorbed;
            damage = ModifyDamage(damage, int.MaxValue, damageType, out fullyAbsorbed);

            // Display damage
            if (visible) // equivalent to dam_message in fight.C:4381
            {
                if (fullyAbsorbed)
                    DisplayUnknownSourceAbsorbPhrase(ability?.Name);
                else
                    DisplayUnknownSourceDamagePhrase(ability?.Name, damage);
            }

            // No damage -> stop here
            if (damage == 0)
            {
                Log.Default.WriteLine(LogLevels.Debug, "{0} does no damage to {1}", ability, DebugName);

                return false;
            }

            Log.Default.WriteLine(LogLevels.Debug, "{0} does {1} damage to {2}", ability, damage, DebugName);

            bool dead = ApplyDamageAndDisplayStatus(damage);

            Log.Default.WriteLine(LogLevels.Debug, "{0} HP left: {1}", DebugName, HitPoints);

            // If dead, create corpse, xp gain/loss, remove character from world if needed
            if (dead) // TODO: fight.C:2246
            {
                Log.Default.WriteLine(LogLevels.Debug, "{0} has been killed by {1}", DebugName, ability);

                StopFighting(false);
                RawKilled(null, false);
                return true;
            }
            return true;
        }

        public bool RawKilled(ICharacter killer, bool killingPayoff)
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "RawKilled: {0} is not valid anymore", DebugName);
                return false;
            }

            string wiznetMsg;
            if (killer != null )
                wiznetMsg = $"{DebugName} got toasted by {killer.DebugName ?? "???"} at {Room?.DebugName ?? "???"}";
            else
                wiznetMsg = $"{DebugName} got toasted by an unknown source at {Room?.DebugName ?? "???"}";
            Server.Wiznet(wiznetMsg, Impersonable
                ? WiznetFlags.Deaths
                : WiznetFlags.MobDeaths);

            StopFighting(true);
            // Remove periodic auras
            List<IPeriodicAura> periodicAuras = new List<IPeriodicAura>(PeriodicAuras); // clone
            foreach (IPeriodicAura pa in periodicAuras)
                RemovePeriodicAura(pa);
            // Remove auras
            List<IAura> auras = new List<IAura>(Auras); // clone
            foreach (IAura aura in auras)
                RemoveAura(aura, false);
            // no need to recompute

            // Death cry
            ActToNotVictim(this, "You hear {0}'s death cry.", this);

            // Gain/lose xp/reputation   damage.C:32
            if (killingPayoff)
                killer?.KillingPayoff(this);
            DeathPayoff();

            // Create corpse
            IItemCorpse corpse;
            if (killer != null)
                corpse = World.AddItemCorpse(Guid.NewGuid(), ServerOptions.CorpseBlueprint, Room, this, killer);
            else
                corpse = World.AddItemCorpse(Guid.NewGuid(), ServerOptions.CorpseBlueprint, Room, this);
            if (ImpersonatedBy != null) // If impersonated, no real death
            {
                // TODO: teleport player to hall room/graveyard  see fight.C:3952
                ResetAttributes(false); // don't reset hp
            }
            else // If not impersonated, remove from game
            {
                World.RemoveCharacter(this);
            }

            // TODO: autoloot, autosac  damage.C:96
            return true;
        }

        // Gain xp/gold/reputation/...
        public void KillingPayoff(ICharacter victim)
        {
            // Gain xp
            if (Impersonable && this != victim && !victim.Impersonable) // gain xp only for non-impersonable victim and only if impersonable
            {
                // TODO: not the best way to do it
                // Build group members
                List<ICharacter> members = new List<ICharacter>
                {
                    this
                };
                ICharacter leader = null;
                // Member of a group
                if (Leader != null && Leader.GroupMembers.Any(x => x == this))
                    leader = Leader;
                // Leader of a group
                else if (Leader == null && GroupMembers.Any())
                    leader = this;
                if (leader != null)
                    members.AddRange(leader.GroupMembers);
                int highestLevel = members.Max(x => x.Level);
                int sumLevels = members.Sum(x => x.Level);
                int memberCount = members.Count;
                // Gain xp
                foreach (ICharacter member in members)
                {
                    long experienceGain;
                    if (memberCount == 1)
                        experienceGain = CombatHelpers.GetSoloMobExperienceFull(member.Level, victim.Level, false /*TODO: elite*/, 0 /*TODO: rested exp*/);
                    else if (memberCount == 2)
                        experienceGain = CombatHelpers.GetDuoMobExperienceFull(members[0].Level, members[1].Level, victim.Level, false /*TODO: elite*/, 0 /*TODO: rested exp*/);
                    else
                        experienceGain = CombatHelpers.GetPartyMobExperienceFull(member.Level, highestLevel, sumLevels, memberCount, victim.Level, false /*TODO: elite*/, 0 /*TODO: rested exp*/);
                    if (experienceGain > 0)
                    {
                        member.Send("%y%You gain {0} experience points.%x%", experienceGain);
                        member.GainExperience(experienceGain);
                    }
                }
            }
        }

        public void GainExperience(long experience)
        {
            if (!Impersonable)
                return;
            if (Level >= ServerOptions.MaxLevel)
            {
                // NOP
            }
            else
            {
                bool recompute = false;
                Experience += experience;
                // Raise level
                if (experience > 0)
                {
                    while (ExperienceToLevel <= 0)
                    {
                        recompute = true;
                        Level++;
                        Server.Wiznet($"{DebugName} has attained level {Level}", WiznetFlags.Levels);
                        Send("You raise a level!!");
                        Act(ActOptions.ToGroup, "{0} has attained level {1}", this, Level);
                        // In case multiple level are gain, check max level
                        if (Level >= ServerOptions.MaxLevel)
                            break;
                    }
                }
                if (recompute)
                {
                    RecomputeBaseAttributes();
                    RecomputeKnownAbilities();
                    RecomputeAttributes();
                    RecomputeCommands();
                    // Bonus -> reset cooldown and set resource to max
                    _cooldowns.Clear();
                    HitPoints = MaxHitPoints;
                    for (int i = 0; i < _currentResources.Length; i++)
                        _currentResources[i] = _maxResources[i];

                    ImpersonatedBy?.Save(); // Force a save when a level is gained
                }
            }
        }

        // Ability
        public IDictionary<IAbility, DateTime> AbilitiesInCooldown => _cooldowns;

        public bool HasAbilitiesInCooldown => _cooldowns.Any();

        public int CooldownSecondsLeft(IAbility ability)
        {
            DateTime nextAvailability;
            if (_cooldowns.TryGetValue(ability, out nextAvailability))
            {
                TimeSpan diff = nextAvailability - TimeHandler.CurrentTime;
                int secondsLeft = (int) Math.Ceiling(diff.TotalSeconds);
                return secondsLeft;
            }
            return int.MinValue;
        }

        public void SetCooldown(IAbility ability)
        {
            DateTime nextAvailability = TimeHandler.CurrentTime.AddSeconds(ability.Cooldown);
            _cooldowns[ability] = nextAvailability;
        }

        public void ResetCooldown(IAbility ability, bool verbose)
        {
            _cooldowns.Remove(ability);
            if (verbose)
                Send("%c%{0} is available.%x%", ability.Name);
        }

        public void AutoLook()
        {
            DisplayRoom();
        }

        #endregion

        protected void ModifyAttribute(PrimaryAttributeTypes attribute, AmountOperators op, int amount)
        {
            if (op == AmountOperators.Percentage)
                amount = _basePrimaryAttributes[(int) attribute]*amount/100;
            this[attribute] += amount;
        }

        protected void ModifyAttribute(SecondaryAttributeTypes attribute, AmountOperators op, int amount)
        {
            if (op == AmountOperators.Percentage)
                amount = _secondaryAttributes[(int) attribute]*amount/100;
            this[attribute] += amount;
        }

        //protected int ModifyAttribute(int baseValue, AmountOperators op, int amount)
        //{
        //    if (op == AmountOperators.Percentage)
        //        amount = baseValue*amount/100;
        //    return baseValue + amount;
        //}

        protected void BuildEquipmentSlots()
        {
            // TODO: depend on race+affects+...
            if (Race != null)
            {
                // TODO: take care of existing equipment (add only new slot, if slot is removed put equipment in inventory)
                _equipments.Clear();
                _equipments.AddRange(Race.EquipmentSlots.Select(x => new EquipedItem(x)));
            }
            else
            {
                _equipments.Add(new EquipedItem(EquipmentSlots.Light));
                _equipments.Add(new EquipedItem(EquipmentSlots.Head));
                _equipments.Add(new EquipedItem(EquipmentSlots.Amulet));
                _equipments.Add(new EquipedItem(EquipmentSlots.Shoulders));
                _equipments.Add(new EquipedItem(EquipmentSlots.Chest));
                _equipments.Add(new EquipedItem(EquipmentSlots.Cloak));
                _equipments.Add(new EquipedItem(EquipmentSlots.Waist));
                _equipments.Add(new EquipedItem(EquipmentSlots.Wrists));
                _equipments.Add(new EquipedItem(EquipmentSlots.Arms));
                _equipments.Add(new EquipedItem(EquipmentSlots.Hands));
                _equipments.Add(new EquipedItem(EquipmentSlots.RingLeft));
                _equipments.Add(new EquipedItem(EquipmentSlots.RingRight));
                _equipments.Add(new EquipedItem(EquipmentSlots.Legs));
                _equipments.Add(new EquipedItem(EquipmentSlots.Feet));
                _equipments.Add(new EquipedItem(EquipmentSlots.Trinket1));
                _equipments.Add(new EquipedItem(EquipmentSlots.Trinket2));
                _equipments.Add(new EquipedItem(EquipmentSlots.Wield));
                _equipments.Add(new EquipedItem(EquipmentSlots.Wield2));
                _equipments.Add(new EquipedItem(EquipmentSlots.Shield));
                _equipments.Add(new EquipedItem(EquipmentSlots.Hold));
            }
        }

        protected void SetGlobalCooldown(int pulseCount) // set GCD (in pulse) if impersonated by
        {
            ImpersonatedBy?.SetGlobalCooldown(pulseCount);
        }

        protected bool ApplyDamageAndDisplayStatus(int damage)
        {
            // Apply damage
            bool dead = false;
            HitPoints -= damage;
            if (HitPoints < 1)
            {
                if (ImpersonatedBy != null) // Impersonated character cannot be totally killed
                    HitPoints = 1;
                else
                    HitPoints = 0;
                dead = true;
            }

            //update_pos(victim);
            //position_msg(victim, dam);

            // position_msg
            if (damage > MaxHitPoints/4)
                Send("That really did HURT!");
            if (!dead && HitPoints < MaxHitPoints/4)
                Send("You sure are BLEEDING!");
            if (dead)
            {
                Act(ActOptions.ToRoom, "{0} is dead.", this);
                Send("You have been KILLED!!");
            }

            return dead;
        }

        protected int ModifyDamage(int damage, int sourceLevel, SchoolTypes damageTypes, out bool fullyAbsorbed)
        {
            // TODO: perform crushing blow, critical, block computation here instead of OneHit and AbilityEffect
            // TODO: check combat_damage in fight.C:1940
            // TODO: damage reduction

            // TODO: if invisible, remove invisibility
            // TODO: damage modifier
            // TODO: check immunity/resist/vuln

            // Check absorb
            fullyAbsorbed = false;
            if (damage > 0 && _auras.Any(x => x.Modifier == AuraModifiers.DamageAbsorb))
            {
                bool needsRecompute = false;
                // Process every absorb aura until 0 damage left or 0 absorb aura left
                IReadOnlyCollection<IAura> absorbs = new ReadOnlyCollection<IAura>(_auras.Where(x => x.Modifier == AuraModifiers.DamageAbsorb).ToList());
                foreach (IAura absorb in absorbs)
                {
                    // Process absorb
                    damage = absorb.Absorb(damage);
                    if (damage == 0) // full absorb
                    {
                        fullyAbsorbed = true;
                        Log.Default.WriteLine(LogLevels.Debug, "Damage [{0}] totally absorbed by {1}", damage, absorb.Ability == null ? "<<??>>" : absorb.Ability.Name);
                        break; // no need to check other absorb
                    }
                    else // partial absorb
                    {
                        Log.Default.WriteLine(LogLevels.Debug, "Damage [{0}] partially absorbed [{1}] by {2}", damage, absorb.Amount, absorb.Ability == null ? "<<??>>" : absorb.Ability.Name);
                        needsRecompute = true;
                        RemoveAura(absorb, false); // recompute when everything is done
                    }
                }
                if (needsRecompute)
                    RecomputeAttributes();
            }

            // Armor reduce physical damage (http://wow.gamepedia.com/Armor#Armor_damage_reduction_formula)
            if (damageTypes == SchoolTypes.Physical)
            {
                // 1 -> 59
                //double damageReduction = (double)this[ComputedAttributeTypes.Armor] / (this[ComputedAttributeTypes.Armor] + 400 + 85 * sourceLevel);
                double denominator = this[SecondaryAttributeTypes.Armor] + 400 + 85*sourceLevel;
                if (sourceLevel >= 60)
                    denominator += 4.5*(sourceLevel - 59);
                if (sourceLevel >= 80)
                    denominator += 20*(sourceLevel - 80);
                if (sourceLevel >= 85)
                    denominator += 22*(sourceLevel - 85);
                double damageReduction = this[SecondaryAttributeTypes.Armor]/denominator;
                if (damageReduction > 0)
                {
                    //double damageAbsorption = HitPoints/(1.0 - damageReduction);
                    damage = damage - (int) (damage*damageReduction);
                }
            }

            // TODO: resistances (see http://wow.gamepedia.com/Resistance/

            return damage;
        }

        protected int ModifyHeal(int heal, out bool fullyAbsorbed)
        {
            fullyAbsorbed = false;
            if (heal > 0 && _auras.Any(x => x.Modifier == AuraModifiers.HealAbsorb))
            {
                bool needsRecompute = false;
                // Process every absorb aura until 0 damage left or 0 absorb aura left
                IReadOnlyCollection<IAura> absorbs = new ReadOnlyCollection<IAura>(_auras.Where(x => x.Modifier == AuraModifiers.HealAbsorb).ToList());
                foreach (IAura absorb in absorbs)
                {
                    // Process absorb
                    heal = absorb.Absorb(heal);
                    if (heal == 0) // full absorb
                    {
                        fullyAbsorbed = true;
                        Log.Default.WriteLine(LogLevels.Debug, "Heal [{0}] totally absorbed by {1}", heal, absorb.Ability == null ? "<<??>>" : absorb.Ability.Name);
                        break; // no need to check other absorb
                    }
                    else // partial absorb
                    {
                        Log.Default.WriteLine(LogLevels.Debug, "Heal [{0}] partially absorbed [{1}] by {2}", heal, absorb.Amount, absorb.Ability == null ? "<<??>>" : absorb.Ability.Name);
                        needsRecompute = true;
                        RemoveAura(absorb, false); // recompute when everything is done
                    }
                }
                if (needsRecompute)
                    RecomputeAttributes();
            }

            return heal;
        }

        protected bool OneHit(ICharacter victim, IItemWeapon weapon, SchoolTypes damageType, bool notMainWield) // TODO: check fight.C:1394
        {
            if (this == victim || Room != victim.Room)
                return false;

            if (Position == Positions.Stunned)
                return false;

            // Starts fight if needed (if A attacks B, A fights B and B fights A)
            if (this != victim)
            {
                if (Fighting == null)
                    StartFighting(victim);
                if (victim.Fighting == null)
                    victim.StartFighting(this);
                // TODO: Cannot attack slave without breaking slavery
            }

            // http://wow.gamepedia.com/Attack_power
            int damage;
            if (weapon != null)
                damage = RandomizeHelpers.Instance.Dice(weapon.DiceCount, weapon.DiceValue) + this[SecondaryAttributeTypes.AttackPower] / 14; // TODO: use weapon dps and weapon speed
            else
            {
                // TEST
                if (ImpersonatedBy != null)
                    damage = 75; // TODO: almost no damage unless hand2hand
                else // http://wow.gamepedia.com/Attack_power (Mob attack power)
                    damage = (this[SecondaryAttributeTypes.AttackPower] / 14) * Level; // TODO: simulate weapon dps using level
            }
            if (notMainWield)
                damage /= 2;
            // TODO: damage modifier  fight.C:1693

            // Miss, dodge, parry, ...
            CombatHelpers.AttackResults attackResult = CombatHelpers.WhiteMeleeAttack(this, victim, notMainWield);
            Log.Default.WriteLine(LogLevels.Debug, $"{DebugName} -> {victim.DebugName} : attack result = {attackResult} for {weapon?.DebugName ?? "???"}");
            switch (attackResult)
            {
                case CombatHelpers.AttackResults.Miss:
                    victim.Act(ActOptions.ToCharacter, "{0} misses you.", this);
                    Act(ActOptions.ToCharacter, "You miss {0}.", victim);
                    return false;
                case CombatHelpers.AttackResults.Dodge:
                    victim.Act(ActOptions.ToCharacter, "You dodge {0}'s attack.", this);
                    Act(ActOptions.ToCharacter, "{0} dodges your attack.", victim);
                    return false;
                case CombatHelpers.AttackResults.Parry:
                    victim.Act(ActOptions.ToCharacter, "You parry {0}'s attack.", this);
                    Act(ActOptions.ToCharacter, "{0} parries your attack.", victim);
                    return false;
                case CombatHelpers.AttackResults.GlancingBlow:
                    // http://wow.gamepedia.com/Glancing_Blow
                    damage = (damage * 75) / 100;
                    break;
                case CombatHelpers.AttackResults.Block:
                    EquipedItem victimShield = victim.Equipments.FirstOrDefault(x => x.Item != null && x.Slot == EquipmentSlots.Shield);
                    if (victimShield != null) // will never be null because MeleeAttack will not return Block if no shield
                    {
                        victim.Act(ActOptions.ToCharacter, "You block {0}'s attack with {1}.", this, victimShield.Item);
                        Act(ActOptions.ToCharacter, "{0} blocks your attack with {1}.", victim, victimShield.Item);
                    }
                    damage = (damage * 7) / 10;
                    break;
                case CombatHelpers.AttackResults.Critical:
                    //  TODO http://wow.gamepedia.com/Critical_strike
                    if (victim.ImpersonatedBy != null) // PVP
                        damage = (damage * 150) / 200;
                    else
                        damage *= 2; // PVE
                    break;
                case CombatHelpers.AttackResults.CrushingBlow:
                    // http://wow.gamepedia.com/Crushing_Blow
                    damage = (damage * 150) / 200;
                    break;
                case CombatHelpers.AttackResults.Hit:
                    // NOP
                    break;
                default:
                    Log.Default.WriteLine(LogLevels.Error, "Unknown MeleeAttack result: {0}", attackResult);
                    break;
            }

            return victim.WeaponDamage(this, weapon, damage, damageType, true);
        }

        protected void DisplayDamageAbsorbPhrase(string name, ICharacter source)
        {
            if (!string.IsNullOrWhiteSpace(name))
            {
                if (this == source)
                {
                    //Act(ActOptions.ToCharacter, "Your {0} is absorbed.", name);
                    //Act(ActOptions.ToRoom, "{0} {1} is absorbed.", source, name);
                    Act(ActOptions.ToAll, "{0:P} {1} is absorbed.", source, name);
                }
                else
                {
                    //if (Room == source.Room)
                    //    source.Act(ActOptions.ToCharacter, "Your {0} is absorbed.", name);
                    //Act(ActOptions.ToCharacter, "{0}'s {1} is absorbed.", source, name);
                    //ActToNotVictim(source, "{0}'s {1} is absorbed by {2}.", source, name, this);
                    Act(ActOptions.ToAll, "{0:P} {1} is absorbed by {2}.", source, name, this);
                }
            }
            else
            {
                if (this == source)
                {
                    //Act(ActOptions.ToCharacter, "You absorb some damage.");
                    //Act(ActOptions.ToRoom, "{0} absorbs some damage.", source);
                    Act(ActOptions.ToAll, "{0:P} absorb{0:v} some damage.", this);
                }
                else
                {
                    //if (Room == source.Room)
                    //    source.Act(ActOptions.ToCharacter, "{0} absorbs your damage.", this);
                    //Act(ActOptions.ToCharacter, "You absorb damage from {0}.", source);
                    //ActToNotVictim(source, "{0} absorbs damage from {1}.", this, source);
                    Act(ActOptions.ToAll, "{0:P} absorb{0:v} damage from {1}", this, source);
                }
            }
        }

        protected void DisplayUnknownSourceAbsorbPhrase(string name)
        {
            if (!string.IsNullOrWhiteSpace(name))
            {
                //Act(ActOptions.ToCharacter, "{0} is absorbed.", name);
                //Act(ActOptions.ToRoom, "{0} is absorbed by {1}.", name, this);
                Act(ActOptions.ToAll, "{0} absorb{0:v} damage from {1}.", this, name);
            }
            else
            {
                //Act(ActOptions.ToCharacter, "You absorb damage.");
                //Act(ActOptions.ToRoom, "{0} absorbs damage.", this);
                Act(ActOptions.ToAll, "{0} absorb{0:v} some damage.", this);
            }
        }

        protected void DisplayDamagePhrase(string name, int damage, ICharacter source)
        {
            string damagePhraseSelf = StringHelpers.DamagePhraseSelf(damage);
            string damagePhraseOther = StringHelpers.DamagePhraseOther(damage);

            if (!string.IsNullOrWhiteSpace(name))
            {
                if (this == source)
                {
                    //Act(ActOptions.ToCharacter, "Your {0} {1} yourself.[{2}]", name, damagePhraseOther, damage);
                    //Act(ActOptions.ToRoom, "{0} {1} {2} {0:m}self.[{3}]", source, name, damagePhraseOther, damage);
                    Act(ActOptions.ToAll, "{0:P} {1} {2} {0:f}.[{3}]", source, name, damagePhraseOther, damage);
                }
                else
                {
                    Act(ActOptions.ToCharacter, "{0}'s {1} {2} you.[{3}]", source, name, damagePhraseOther, damage);
                    if (Room == source.Room)
                        source.Act(ActOptions.ToCharacter, "Your {0} {1} {2}.[{3}]", name, damagePhraseSelf, this, damage);
                    ActToNotVictim(source, "{0}'s {1} {2} {3}.[{4}]", source, name, damagePhraseOther, this, damage);
                    // TODO: damagePhraseOther and damagePhraseSelf should be merge and include {0:v}
                    //Act(ActOptions.ToAll, "{0:P} {1} {2} {3}.[{4}]", source, name, damagePhraseOther, this, damage);
                }
            }
            else
            {
                if (this == source)
                {
                    Act(ActOptions.ToCharacter, "You {0} yourself.[{1}]", damagePhraseSelf, damage);
                    Act(ActOptions.ToRoom, "{0} {1} {0:m}self.[{2}]", source, damagePhraseOther, damage);
                }
                else
                {
                    Act(ActOptions.ToCharacter, "{0} {1} you.[{2}]", source, damagePhraseOther, damage);
                    if (Room == source.Room)
                        source.Act(ActOptions.ToCharacter, "You {0} {1}.[{2}]", damagePhraseSelf, this, damage);
                    ActToNotVictim(source, "{0} {1} {2}.[{3}]", source, damagePhraseOther, this, damage);
                    // TODO: damagePhraseOther and damagePhraseSelf should be merge and include {0:v}
                }
            }
        }

        protected void DisplayUnknownSourceDamagePhrase(string name, int damage)
        {
            string damagePhraseSelf = StringHelpers.DamagePhraseSelf(damage);
            string damagePhraseOther = StringHelpers.DamagePhraseOther(damage);

            if (!string.IsNullOrWhiteSpace(name))
            {
                Act(ActOptions.ToCharacter, "{0} {1} you.[{2}]", name, damagePhraseSelf, damage);
                Act(ActOptions.ToRoom, "{0} {1} {2}.[{3}]", name, damagePhraseOther, this, damage);
                // TODO: damagePhraseOther and damagePhraseSelf should be merge and include {0:v}
            }
            else
            {
                Log.Default.WriteLine(LogLevels.Warning, "ICharacter.NonCombatDamage: no ability");
                Act(ActOptions.ToCharacter, "Something {0} you.[{1}]", damagePhraseOther, damage);
                Act(ActOptions.ToRoom, "Something {0} {1}.[{2}]", damagePhraseOther, this, damage);
                // TODO: damagePhraseOther and damagePhraseSelf should be merge and include {0:v}
            }
        }

        protected void DisplayHealPhrase(IAbility ability, int amount, ICharacter source)
        {
            if (ability != null)
            {
                if (this == source)
                {
                    Act(ActOptions.ToCharacter, "Your {0} %W%heals%x% yourself.[{1}]", ability, amount);
                    Act(ActOptions.ToRoom, "{0} {1} %W%heals%x% {0:m}self.[{2}]", this, ability, amount);
                }
                else
                {
                    Act(ActOptions.ToCharacter, "{0}'s {1} %W%heals%x% you.[{2}]", source, ability, amount);
                    if (Room == source.Room)
                        source.Act(ActOptions.ToCharacter, "Your {0} %W%heals%x% {1}.[{2}]", ability, this, amount);
                    ActToNotVictim(source, "{0}'s {1} %W%heals%x% {2}.[{3}]", source, ability, this, amount);
                }
            }
            else
            {
                if (this == source)
                {
                    Act(ActOptions.ToCharacter, "You %W%heal%x% yourself.[{0}]", amount);
                    Act(ActOptions.ToRoom, "{0} %W%heals%x% {0:m}self.[{1}]", this, amount);
                }
                else
                {
                    Act(ActOptions.ToCharacter, "{0} heals you.[{1}]", source, amount);
                    if (Room == source.Room)
                        source.Act(ActOptions.ToCharacter, "You heal {0}.[{1}]", this, amount);
                    ActToNotVictim(source, "{0} heals {1}.[{2}]", source, this, amount);
                }
            }
        }

        protected void DisplayHealAbsorbPhrase(string name, ICharacter source)
        {
            if (!string.IsNullOrWhiteSpace(name))
            {
                if (this == source)
                {
                    Act(ActOptions.ToCharacter, "Your {0} is absorbed.", name);
                    Act(ActOptions.ToRoom, "{0} {1} is absorbed.", source, name);
                }
                else
                {
                    Act(ActOptions.ToCharacter, "{0}'s {1} is absorbed.", source, name);
                    if (Room == source.Room)
                        source.Act(ActOptions.ToCharacter, "Your {0} is absorbed.", name);
                    ActToNotVictim(source, "{0}'s {1} is absorbed by {2}.", source, name, this);
                }
            }
            else
            {
                if (this == source)
                {
                    Act(ActOptions.ToCharacter, "You absorb some heal.");
                    Act(ActOptions.ToRoom, "{0} absorbs some heal.", source);
                }
                else
                {
                    Act(ActOptions.ToCharacter, "You absorb heal from {0}.", source);
                    if (Room == source.Room)
                        source.Act(ActOptions.ToCharacter, "{0} absorbs your heal.", this);
                    ActToNotVictim(source, "{0} absorbs heal from {1}.", this, source);
                }
            }
        }

        protected void RecomputeBaseAttributes()
        {
            for (int i = 0; i < _basePrimaryAttributes.Length; i++)
                _basePrimaryAttributes[i] = (Class?.GetPrimaryAttributeByLevel((PrimaryAttributeTypes) i, Level) ?? 10*Level) + (Race?.GetPrimaryAttributeModifier((PrimaryAttributeTypes) i) ?? 0);
        }

        // TODO: Should recompute attributes/commands afterwards
        protected void RecomputeKnownAbilities()
        {
            // Add abilities from Class/Race/...
            _knownAbilities.Clear();

            // Admins know every abilities
            //if (ImpersonatedBy is IAdmin)
            //    _knownAbilities.AddRange(AbilityManager.Abilities.Select(x => new AbilityAndLevel(1,x)));
            //else
            {
                if (Class != null)
                    _knownAbilities.AddRange(Class.Abilities);
                if (Race != null)
                    _knownAbilities.AddRange(Race.Abilities);
                // TODO: if multiple identical abilities, keep only one with lowest level
            }
        }

        // TODO: should recompute only of different from previous
        protected void RecomputeCommands()
        {
            // Clear actual commands
            _fullCommands.Clear();
            // Add Character commands
            _fullCommands.AddRange(CharacterCommands.Value.AsEnumerable().Select(x => new TrieEntry<CommandMethodInfo>(x.Key, x.Value))); // TODO: additional AddRange taking a IEnumerable<KeyValuePair<string,TValue>> or IDictionary<string,TValue>
            // Add Skill command
            List<TrieEntry<CommandMethodInfo>> skillCommands = new List<TrieEntry<CommandMethodInfo>>();
            foreach (AbilityAndLevel abilityAndLevel in _knownAbilities.Where(x => x.Level <= Level && x.Ability.Kind == AbilityKinds.Skill && (x.Ability.Flags & AbilityFlags.Passive) != AbilityFlags.Passive && (x.Ability.Flags & AbilityFlags.CannotBeUsed) != AbilityFlags.CannotBeUsed))
            {
                string commandName = abilityAndLevel.Ability.Name.ToLower();
                CommandAttribute ca = new CommandAttribute(commandName)
                {
                    Category = "Skill",
                    Hidden = false,
                    Priority = 1,
                    AddCommandInParameters = true // !! this is mandatory
                };
                Func<string, CommandParameter[], bool> func = (rawParameters, parameters) => AbilityManager.Process(this, parameters);
                CommandMethodInfo cmi = new CommandMethodInfo(ca, func.Method);
                skillCommands.Add(new TrieEntry<CommandMethodInfo>(commandName, cmi));
            }
            if (skillCommands.Any())
                _fullCommands.AddRange(skillCommands);
        }

        protected void RecomputeCurrentResourceKinds()
        {
            // Get current resource kind from class if any, every resource otherwise
            CurrentResourceKinds = (Class?.CurrentResourceKinds(Form) ?? EnumHelpers.GetValues<ResourceKinds>()).Where(x => x != ResourceKinds.None).ToList();
        }

        protected int ComputeArmorFromEquipments()
        {
            int armorValue = 0;
            foreach (EquipedItem equipedItem in Equipments.Where(x => x.Item != null))
            {
                IItemArmor armor = equipedItem.Item as IItemArmor;
                if (armor != null)
                    armorValue += armor.Armor;
                else
                {
                    IItemShield shield = equipedItem.Item as IItemShield;
                    if (shield != null)
                        armorValue += shield.Armor;
                }
            }
            return armorValue;
        }

        protected bool GenericDamage(ICharacter source, string sourceName /*can be source.DisplayName or source.Weapon.DisplayName*/, int damage, SchoolTypes damageType, bool visible)
        {
            if (!IsValid)
            {
                Log.Default.WriteLine(LogLevels.Error, "CombatDamage: {0} is not valid anymore", DebugName);
                return false;
            }

            // Starts fight if needed (if A attacks B, A fights B and B fights A)
            if (this != source)
            {
                if (Fighting == null)
                    StartFighting(source);
                if (source.Fighting == null)
                    source.StartFighting(this);
                // TODO: Cannot attack slave without breaking slavery
            }

            // Modify damage (resist, vuln, invul, absorb)
            bool fullyAbsorbed;
            damage = ModifyDamage(damage, source.Level, damageType, out fullyAbsorbed);

            // Display damage
            if (visible) // equivalent to dam_message in fight.C:4381
            {
                if (fullyAbsorbed)
                    DisplayDamageAbsorbPhrase(sourceName, source);
                else
                    DisplayDamagePhrase(sourceName, damage, source);
            }

            // No damage -> stop here
            if (damage == 0)
            {
                Log.Default.WriteLine(LogLevels.Debug, "{0} does no damage to {1}", source.DebugName, DebugName);

                return false;
            }

            Log.Default.WriteLine(LogLevels.Debug, "{0} does {1} damage to {2}", source.DebugName, damage, DebugName);

            // Apply damage
            bool dead = ApplyDamageAndDisplayStatus(damage);

            Log.Default.WriteLine(LogLevels.Debug, "{0} HP: {1}", DebugName, HitPoints);

            // If dead, create corpse, xp gain/loss, remove character from world if needed
            if (dead) // TODO: fight.C:2246
            {
                Log.Default.WriteLine(LogLevels.Debug, "{0} has been killed by {1}", DebugName, source.DebugName);

                StopFighting(false);
                RawKilled(source, true);
                return true;
            }

            // TODO: wimpy, ... // fight.C:2264

            return true;
        }

        // Lose xp/reputation/durability/...
        protected void DeathPayoff()
        {
            // TODO
        }

        #region Act

        // Recreate behaviour of String.Format with maximum 10 arguments
        // If an argument is ICharacter, IItem, IExit special formatting is applied (depending on who'll receive the message)
        private enum ActParsingStates
        {
            Normal,
            OpeningBracketFound,
            ArgumentFound,
            FormatSeparatorFound,
        }

        private static string FormatActOneLine(ICharacter target, string format, params object[] arguments)
        {
            StringBuilder result = new StringBuilder();

            ActParsingStates state = ActParsingStates.Normal;
            object currentArgument = null;
            StringBuilder argumentFormat = null;
            foreach (char c in format)
            {
                switch (state)
                {
                    case ActParsingStates.Normal: // searching for {
                        if (c == '{')
                        {
                            state = ActParsingStates.OpeningBracketFound;
                            currentArgument = null;
                            argumentFormat = new StringBuilder();
                        }
                        else
                            result.Append(c);
                        break;
                    case ActParsingStates.OpeningBracketFound: // searching for a number
                        if (c == '{') // {{ -> {
                        {
                            result.Append('{');
                            state = ActParsingStates.Normal;
                        }
                        else if (c == '}') // {} -> nothing
                        {
                            state = ActParsingStates.Normal;
                        }
                        else if (c >= '0' && c <= '9') // {x -> argument found
                        {
                            currentArgument = arguments[c - '0'];
                            state = ActParsingStates.ArgumentFound;
                        }
                        break;
                    case ActParsingStates.ArgumentFound: // searching for } or :
                        if (c == '}')
                        {
                            FormatActOneArgument(target, result, null, currentArgument);
                            state = ActParsingStates.Normal;
                        }
                        else if (c == ':')
                            state = ActParsingStates.FormatSeparatorFound;
                        break;
                    case ActParsingStates.FormatSeparatorFound: // searching for }
                        if (c == '}')
                        {
                            FormatActOneArgument(target, result, argumentFormat.ToString(), currentArgument);
                            state = ActParsingStates.Normal;
                        }
                        else
                        {
                            // argumentFormat cannot be null
                            argumentFormat.Append(c);
                        }
                        break;
                }
            }
            if (result.Length > 0)
                result[0] = char.ToUpperInvariant(result[0]);
            return result.ToString();
        }

        // Formatting
        //  ICharacter
        //      default: same as n, N
        //      p, P: same as n but you is replaced with your
        //      n, N: argument.name if visible by target, someone otherwise
        //      e, E: you/he/she/it, depending on argument.sex
        //      m, M: you/him/her/it, depending on argument.sex
        //      s, S: your/his/her/its, depending on argument.sex
        //      f, F: yourself/himself/herself/itself
        //      b, B: are/is
        //      h, H: have/has
        //      v, V: add 's' at the end of a verb if argument is different than target (take care of verb ending with y/o/h
        // IItem
        //      argument.Name if visible by target, something otherwhise
        // IExit
        //      exit name
        // IAbility
        //      ability name
        private static void FormatActOneArgument(ICharacter target, StringBuilder result, string format, object argument)
        {
            // Character ?
            ICharacter character = argument as ICharacter;
            if (character != null)
            {
                char letter = format?[0] ?? 'n'; // if no format, n
                switch (letter)
                {
                    // your/name
                    case 'p':
                        if (target == character)
                            result.Append("your");
                        else
                        {
                            result.Append(character.RelativeDisplayName(target));
                            if (result[result.Length - 1] == 's')
                                result.Append('\'');
                            else
                                result.Append("'s");
                        }
                        break;
                    case 'P':
                        if (target == character)
                            result.Append("Your");
                        else
                        {
                            result.Append(character.RelativeDisplayName(target));
                            if (result[result.Length - 1] == 's')
                                result.Append('\'');
                            else
                                result.Append("'s");
                        }
                        break;
                    // you/name
                    case 'n':
                        if (target == character)
                            result.Append("you");
                        else
                            result.Append(character.RelativeDisplayName(target));
                        break;
                    case 'N':
                        if (target == character)
                            result.Append("You");
                        else
                            result.Append(character.RelativeDisplayName(target));
                        break;
                    // you/he/she/it
                    case 'e':
                        if (target == character)
                            result.Append("you");
                        else
                            result.Append(StringHelpers.Subjects[character.Sex]);
                        break;
                    case 'E':
                        if (target == character)
                            result.Append("You");
                        else
                            result.Append(StringHelpers.UpperFirstLetter(StringHelpers.Subjects[character.Sex]));
                        break;
                    // you/him/her/it
                    case 'm':
                        if (target == character)
                            result.Append("you");
                        else
                            result.Append(StringHelpers.Objectives[character.Sex]);
                        break;
                    case 'M':
                        if (target == character)
                            result.Append("You");
                        else
                            result.Append(StringHelpers.UpperFirstLetter(StringHelpers.Objectives[character.Sex]));
                        break;
                    // your/his/her/its
                    case 's':
                        if (target == character)
                            result.Append("your");
                        else
                            result.Append(StringHelpers.Possessives[character.Sex]);
                        break;
                    case 'S':
                        if (target == character)
                            result.Append("Your");
                        else
                            result.Append(StringHelpers.UpperFirstLetter(StringHelpers.Possessives[character.Sex]));
                        break;
                    // yourself/himself/herself/itself (almost same as 'm' + self)
                    case 'f':
                        if (target == character)
                            result.Append("your");
                        else
                            result.Append(StringHelpers.Objectives[character.Sex]);
                        result.Append("self");
                        break;
                    case 'F':
                        if (target == character)
                            result.Append("your");
                        else
                            result.Append(StringHelpers.UpperFirstLetter(StringHelpers.Objectives[character.Sex]));
                        result.Append("self");
                        break;
                    // is/are
                    case 'b':
                        if (target == character)
                            result.Append("are");
                        else
                            result.Append("is");
                        break;
                    case 'B':
                        if (target == character)
                            result.Append("Are");
                        else
                            result.Append("Is");
                        break;
                    // has/have
                    case 'h':
                        if (target == character)
                            result.Append("have");
                        else
                            result.Append("has");
                        break;
                    case 'H':
                        if (target == character)
                            result.Append("Have");
                        else
                            result.Append("Has");
                        break;
                    // verb
                    case 'v':
                    case 'V':
                        // nothing to do if target is actor
                        if (target != character)
                        {
                            //http://www.grammar.cl/Present/Verbs_Third_Person.htm
                            if (result.Length > 0)
                            {
                                char verbLastLetter = result[result.Length - 1];
                                char verbBeforeLastLetter = result.Length > 1 ? result[result.Length - 2] : ' ';
                                if (verbLastLetter == 'y' && verbBeforeLastLetter != ' ' && verbBeforeLastLetter != 'a' && verbBeforeLastLetter != 'e' && verbBeforeLastLetter != 'i' && verbBeforeLastLetter != 'o' && verbBeforeLastLetter != 'u')
                                {
                                    result.Remove(result.Length - 1, 1);
                                    result.Append("ies");
                                }
                                else if (verbLastLetter == 'o' || verbLastLetter == 'h' || verbLastLetter == 's' || verbLastLetter == 'x')
                                    result.Append("es");
                                else
                                    result.Append("s");
                            }
                            else
                                Log.Default.WriteLine(LogLevels.Error, "Act: v-format on an empty string");
                        }
                        break;
                    default:
                        Log.Default.WriteLine(LogLevels.Error, "Act: invalid format {0} for ICharacter", format);
                        result.Append("<???>");
                        break;
                }
                return;
            }
            // Item ?
            IItem item = argument as IItem;
            if (item != null)
            {
                // no specific format
                result.Append(item.RelativeDisplayName(target));
                return;
            }
            // Exit ?
            IExit exit = argument as IExit;
            if (exit != null)
            {
                // no specific format
                result.Append(exit.Keywords.FirstOrDefault() ?? "door");
                return;
            }
            // Ability ?
            IAbility ability = argument as IAbility;
            if (ability != null)
            {
                // no specific format
                result.Append(ability.Name);
                return;
            }
            // Other (int, string, ...)
            if (format == null)
                result.Append(argument);
            else
            {
                IFormattable formattable = argument as IFormattable;
                if (formattable != null)
                    result.Append(formattable.ToString(format, null));
                else
                    result.Append(argument);
            }
        }

        #endregion

        private class CompareIAbility : IEqualityComparer<IAbility>
        {
            public bool Equals(IAbility x, IAbility y)
            {
                if (x == null && y == null)
                    return true;
                if (x == null || y == null)
                    return false;
                return x.Id == y.Id;
            }

            public int GetHashCode(IAbility obj)
            {
                if (obj == null)
                    return -1;
                else
                    return obj.Id;
            }
        }
    }
}
